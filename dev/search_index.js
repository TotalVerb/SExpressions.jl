var documenterSearchIndex = {"docs":
[{"location":"#SExpressions.jl-1","page":"SExpressions.jl","title":"SExpressions.jl","text":"","category":"section"},{"location":"#","page":"SExpressions.jl","title":"SExpressions.jl","text":"SExpressions.jl includes a roughly Racket-compatible parser for s-expressions.","category":"page"},{"location":"#","page":"SExpressions.jl","title":"SExpressions.jl","text":"","category":"page"},{"location":"#Lists-1","page":"SExpressions.jl","title":"Lists","text":"","category":"section"},{"location":"#","page":"SExpressions.jl","title":"SExpressions.jl","text":"Modules = [Lists]\nOrder   = [:function, :type]","category":"page"},{"location":"#SExpressions.Lists.cdr-Tuple{Cons}","page":"SExpressions.jl","title":"SExpressions.Lists.cdr","text":"The tail of a List.\n\nNote that the tail need not be a list (or even a List) if the list is improper.\n\n\n\n\n\n","category":"method"},{"location":"#SExpressions.Lists.islist-Tuple{Nil}","page":"SExpressions.jl","title":"SExpressions.Lists.islist","text":"Return true if the provided List is in fact a list, i.e., it is not improper.\n\nThis is the case if the list is a Nil (empty list) or a Cons with a proper list as its tail.\n\n\n\n\n\n","category":"method"},{"location":"#SExpressions.Lists.Cons","page":"SExpressions.jl","title":"SExpressions.Lists.Cons","text":"An object which is essentially a pair of two objects.\n\nThe two objects are referred to, for historical reasons, as car and cdr.These abbreviations are not semantically relevant today, so can generally be thought of as the head object and the tail object. For Cons objects which are (proper) lists, the car (head) object will be the first element of the list, and the cdr (tail) object will be a list representing the remaining elements.\n\n\n\n\n\n","category":"type"},{"location":"#SExpressions.Lists.Nil","page":"SExpressions.jl","title":"SExpressions.Lists.Nil","text":"An object representing nothing, or an empty list.\n\nThe singleton instance of this type is called nil. This type is isomorphic to, and very similar, to Nothing. However, it is often useful to distinguish the nil used within many lisp dialects from a true Nothing, because nil is iterable and represents an empty list.\n\n\n\n\n\n","category":"type"},{"location":"#SExpressions.Lists.unparse-Tuple{Union{Nil, Cons}}","page":"SExpressions.jl","title":"SExpressions.Lists.unparse","text":"Convenience function to produce compact strings from (proper) lists of lisp objects.\n\n\n\n\n\n","category":"method"},{"location":"#Core-Parser-Interface-1","page":"SExpressions.jl","title":"Core Parser Interface","text":"","category":"section"},{"location":"#","page":"SExpressions.jl","title":"SExpressions.jl","text":"SExpressions.parse\nSExpressions.parseall\nSExpressions.parsefile","category":"page"},{"location":"#SExpressions.Parser.parse","page":"SExpressions.jl","title":"SExpressions.Parser.parse","text":"parse(s::AbstractString)\n\nRead the given string s as a single s-expression. The alternative vocabulary Base.parse(SExpression, s) is also supported and may be preferred.\n\n\n\n\n\nparse(io::IO)\n\nRead a single object from the given io stream.\n\n\n\n\n\n","category":"function"},{"location":"#SExpressions.Parser.parseall","page":"SExpressions.jl","title":"SExpressions.Parser.parseall","text":"parseall(io::IO)\nparseall(s::AbstractString)\n\nParse all objects from the given stream or string into a single list.\n\n\n\n\n\n","category":"function"},{"location":"#SExpressions.Parser.parsefile","page":"SExpressions.jl","title":"SExpressions.Parser.parsefile","text":"parsefile(filename::AbstractString)\n\nParse a file into a single list.\n\n\n\n\n\n","category":"function"}]
}
